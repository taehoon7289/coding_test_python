def solution(n, count):
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    dp[1][1] = 1
    for i in range(2, n + 1):
        for j in range(1, n + 1):
            dp[i][j] = (dp[i - 1][j] * 2 * (i - 1)) + dp[i - 1][j - 1]
    return dp[n][count] % 1_000_000_007


if __name__ == '__main__':
    print(solution(3, 1))
    print(solution(3, 2))
    print(solution(3, 3))

# 같은 높이를 가지는 빌딩 사이에는 그보다 높은 빌딩이 존재하지 않습니다
# dp[i][c] = [0,0]
# n = 1
# -> 1,1 -> 1

# n = 2
# -> 2,2 -> 1122 -> 1 오름차순
# -> 2,1 -> 2211, 2112 -> 2, 앞, 감싸는거 -> , 2 * (dp[i-1][i-1] + ... + dp[i-1][1])
# dp[1] * 2 + dp[1] -> 3

# n = 3
# -> 3,3 -> 112233 -> 1 오름차순
# -> 3,2 -> 113223, 113322, 211233, 221133, 223113, 223311 -> 6 ,, 2 * (dp[i-1][i-1] + ... + dp[i-1][1])
# -> 3,1 -> 311223, 311322, 321123, 322113, 322311, 331122, 332112, 332211 -> 8
# -> 15

# n = 4 일때 추론!!! -> n이 커짐에따라 이전에서 가장 작은 빌딩이 어디를 들어갈수있을지에 대한 경우의 숫자 확인
# (4,1) 은 (3,1)에서 두번째부터 마지막까지 가장 작은게 들어갈수있는 경우의수
# (4,1) = (3,1) * 6
# (4,2) 은 (3,1)에서 맨처음과 (3,2) 두번째부터 마지막까지 가장 작은게 들어갈수있는 경우의수
# (4,2) = (3,1) + (3,2) * 6
# (4,3) 은 (3,2) 맨처음과 (3,3)에서 두번째부터 마지막까지 가장 작은게 들어갈수있는 경우의수
# (4,3) = (3,2) + (3,3) * 6
# (4,4) = 1
